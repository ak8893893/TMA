<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFT Wallet Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <style>
        .container { 
            padding: 20px; 
            max-width: 1200px; 
            margin: 0 auto; 
        }
        .button { 
            background: #3498db; 
            color: white; 
            padding: 10px 20px; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
            margin: 5px;
        }
        .button:hover { 
            background: #2980b9; 
        }
        .button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        .error { 
            color: #e74c3c; 
            margin: 10px 0;
            padding: 10px;
            background: #fadbd8;
            border-radius: 4px;
        }
        .success { 
            color: #27ae60; 
            margin: 10px 0;
            padding: 10px;
            background: #d4efdf;
            border-radius: 4px;
        }
        .network-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .contract-info {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .claim-info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .input-field {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
            width: 100px;
        }
        .loading {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 8px;
        }
        .status-badge.active {
            background: #dff0d8;
            color: #3c763d;
        }
        .status-badge.pending {
            background: #fcf8e3;
            color: #8a6d3b;
        }
    </style>
</head>
<body>
    <div id="root"></div>
</body>
</html>

<script type="text/babel">
    // 定義網絡配置
    const NETWORKS = {
        MANTLE: {
            chainId: '0x1388',
            chainName: 'Mantle',
            nativeCurrency: {
                name: 'MNT',
                symbol: 'MNT',
                decimals: 18
            },
            rpcUrls: ['https://rpc.mantle.xyz'],
            blockExplorerUrls: ['https://explorer.mantle.xyz']
        },
        BASE: {
            chainId: '0x2105',
            chainName: 'Base Mainnet',
            nativeCurrency: {
                name: 'ETH',
                symbol: 'ETH',
                decimals: 18
            },
            rpcUrls: ['https://mainnet.base.org'],
            blockExplorerUrls: ['https://basescan.org']
        }
    };

    // 完整的合約 ABI
    const contractABI = [
{
    "inputs": [],
    "stateMutability": "nonpayable",
    "type": "constructor"
},
{
    "inputs": [],
    "name": "ApprovalCallerNotOwnerNorApproved",
    "type": "error"
},
{
    "inputs": [
        {
            "internalType": "address",
            "name": "operator",
            "type": "address"
        },
        {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
        }
    ],
    "name": "approve",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
},
{
    "inputs": [
        {
            "internalType": "address",
            "name": "owner",
            "type": "address"
        }
    ],
    "name": "balanceOf",
    "outputs": [
        {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
{
    "inputs": [
        {
            "internalType": "address",
            "name": "_receiver",
            "type": "address"
        },
        {
            "internalType": "uint256",
            "name": "_quantity",
            "type": "uint256"
        },
        {
            "internalType": "address",
            "name": "_currency",
            "type": "address"
        },
        {
            "internalType": "uint256",
            "name": "_pricePerToken",
            "type": "uint256"
        },
        {
            "components": [
                {
                    "internalType": "bytes32[]",
                    "name": "proof",
                    "type": "bytes32[]"
                },
                {
                    "internalType": "uint256",
                    "name": "quantityLimitPerWallet",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "pricePerToken",
                    "type": "uint256"
                },
                {
                    "internalType": "address",
                    "name": "currency",
                    "type": "address"
                }
            ],
            "internalType": "struct IDrop.AllowlistProof",
            "name": "_allowlistProof",
            "type": "tuple"
        },
        {
            "internalType": "bytes",
            "name": "_data",
            "type": "bytes"
        }
    ],
    "name": "claim",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
},
{
    "inputs": [],
    "name": "getActiveClaimConditionId",
    "outputs": [
        {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
{
    "inputs": [
        {
            "internalType": "uint256",
            "name": "_conditionId",
            "type": "uint256"
        }
    ],
    "name": "getClaimConditionById",
    "outputs": [
        {
            "components": [
                {
                    "internalType": "uint256",
                    "name": "startTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "maxClaimableSupply",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "supplyClaimed",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "quantityLimitPerWallet",
                    "type": "uint256"
                },
                {
                    "internalType": "bytes32",
                    "name": "merkleRoot",
                    "type": "bytes32"
                },
                {
                    "internalType": "uint256",
                    "name": "pricePerToken",
                    "type": "uint256"
                },
                {
                    "internalType": "address",
                    "name": "currency",
                    "type": "address"
                },
                {
                    "internalType": "string",
                    "name": "metadata",
                    "type": "string"
                }
            ],
            "internalType": "struct IClaimCondition.ClaimCondition",
            "name": "condition",
            "type": "tuple"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
{
    "inputs": [],
    "name": "maxTotalSupply",
    "outputs": [
        {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
{
    "inputs": [],
    "name": "name",
    "outputs": [
        {
            "internalType": "string",
            "name": "",
            "type": "string"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
{
    "inputs": [],
    "name": "symbol",
    "outputs": [
        {
            "internalType": "string",
            "name": "",
            "type": "string"
        }
    ],
    "stateMutability": "view",
    "type": "function"
},
{
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
        {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
        }
    ],
    "stateMutability": "view",
    "type": "function"
}
];


function NFTWalletDemo() {
            const [account, setAccount] = React.useState('');
            const [nfts, setNfts] = React.useState([]);
            const [isConnected, setIsConnected] = React.useState(false);
            const [error, setError] = React.useState('');
            const [success, setSuccess] = React.useState('');
            const [networkInfo, setNetworkInfo] = React.useState({});
            const [isLoading, setIsLoading] = React.useState(false);
            const [contractInfo, setContractInfo] = React.useState({
                name: '',
                symbol: '',
                totalSupply: 0,
                maxSupply: 0
            });
            const [claimInfo, setClaimInfo] = React.useState(null);
            const [claimAmount, setClaimAmount] = React.useState(1);

            const contractAddress = '0xc799d8f3ad911a03ac1e1f93baa2e961b4047803';

            const getNetworkInfo = async () => {
                try {
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    const network = await provider.getNetwork();
                    const chainId = await window.ethereum.request({ 
                        method: 'eth_chainId' 
                    });
                    setNetworkInfo({
                        name: network.name,
                        chainId: chainId
                    });
                } catch (err) {
                    console.error('獲取網絡信息錯誤:', err);
                }
            };

            const switchNetwork = async (networkKey) => {
                try {
                    const network = NETWORKS[networkKey];
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [
                            {
                                chainId: network.chainId,
                                chainName: network.chainName,
                                nativeCurrency: network.nativeCurrency,
                                rpcUrls: network.rpcUrls,
                                blockExplorerUrls: network.blockExplorerUrls
                            }
                        ]
                    });
                    await getNetworkInfo();
                    if (isConnected) {
                        await getContractInfo();
                    }
                } catch (error) {
                    console.error('切換網絡錯誤:', error);
                    setError('切換網絡失敗: ' + error.message);
                }
            };

            const connectWallet = async () => {
                setError('');
                setIsLoading(true);
                try {
                    if (window.ethereum) {
                        const accounts = await window.ethereum.request({
                            method: 'eth_requestAccounts'
                        });
                        setAccount(accounts[0]);
                        setIsConnected(true);
                        await getNetworkInfo();
                        await getContractInfo();
                    } else {
                        setError('請安裝 MetaMask!');
                    }
                } catch (error) {
                    console.error('連接錢包錯誤:', error);
                    setError('連接錢包失敗: ' + error.message);
                } finally {
                    setIsLoading(false);
                }
            };

            const getContractInfo = async () => {
                try {
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    const signer = provider.getSigner();
                    const contract = new ethers.Contract(contractAddress, contractABI, signer);

                    const [name, symbol, totalSupply, maxSupply] = await Promise.all([
                        contract.name(),
                        contract.symbol(),
                        contract.totalSupply(),
                        contract.maxTotalSupply()
                    ]);

                    setContractInfo({
                        name,
                        symbol,
                        totalSupply: totalSupply.toString(),
                        maxSupply: maxSupply.toString()
                    });

                    // 獲取當前 claim condition
                    const currentConditionId = await contract.getActiveClaimConditionId();
                    const claimCondition = await contract.getClaimConditionById(currentConditionId);

                    setClaimInfo({
                        maxClaimable: claimCondition.maxClaimableSupply.toString(),
                        claimed: claimCondition.supplyClaimed.toString(),
                        price: ethers.utils.formatEther(claimCondition.pricePerToken),
                        maxPerWallet: claimCondition.quantityLimitPerWallet.toString(),
                        currency: claimCondition.currency
                    });

                } catch (error) {
                    console.error('獲取合約信息錯誤:', error);
                    setError('獲取合約信息失敗: ' + error.message);
                }
            };

            const claim = async () => {
                if (!claimAmount || claimAmount <= 0) {
                    setError('請輸入正確的數量');
                    return;
                }

                setError('');
                setSuccess('');
                setIsLoading(true);

                try {
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    const signer = provider.getSigner();
                    const contract = new ethers.Contract(contractAddress, contractABI, signer);

                    const tx = await contract.claim(
                        account,
                        claimAmount,
                        claimInfo.currency,
                        ethers.utils.parseEther(claimInfo.price),
                        { 
                            proof: [], 
                            quantityLimitPerWallet: 0, 
                            pricePerToken: 0, 
                            currency: ethers.constants.AddressZero 
                        },
                        "0x",
                        { 
                            value: ethers.utils.parseEther(
                                (Number(claimInfo.price) * claimAmount).toString()
                            ) 
                        }
                    );

                    setSuccess('Claim 交易已發送，等待確認...');
                    
                    await tx.wait();
                    setSuccess('Claim 成功！');
                    await getContractInfo();
                } catch (error) {
                    console.error('Claim 錯誤:', error);
                    setError('Claim 失敗: ' + error.message);
                } finally {
                    setIsLoading(false);
                }
            };

            React.useEffect(() => {
                if (window.ethereum) {
                    window.ethereum.on('chainChanged', async (chainId) => {
                        await getNetworkInfo();
                        if (account) {
                            await getContractInfo();
                        }
                    });

                    window.ethereum.on('accountsChanged', async (accounts) => {
                        if (accounts.length > 0) {
                            setAccount(accounts[0]);
                            await getContractInfo();
                        } else {
                            setAccount('');
                            setIsConnected(false);
                        }
                    });
                }
            }, [account]);


            return (
                <div className="container">
                    <h1>NFT Drop Demo</h1>
                    
                    {!isConnected ? (
                        <button 
                            className="button" 
                            onClick={connectWallet} 
                            disabled={isLoading}
                        >
                            {isLoading ? '連接中...' : '連接錢包'}
                        </button>
                    ) : (
                        <div>
                            <div className="network-info">
                                <p>錢包地址: {account}</p>
                                <p>網絡名稱: {networkInfo.name || 'Unknown'}</p>
                                <p>Chain ID: {networkInfo.chainId || 'Unknown'}</p>
                                
                                <div style={{ marginTop: '10px' }}>
                                    <button 
                                        className="button" 
                                        onClick={() => switchNetwork('MANTLE')}
                                        disabled={isLoading}
                                    >
                                        切換到 Mantle
                                    </button>
                                    <button 
                                        className="button" 
                                        onClick={() => switchNetwork('BASE')}
                                        disabled={isLoading}
                                    >
                                        切換到 Base
                                    </button>
                                </div>
                            </div>

                            {contractInfo.name && (
                                <div className="contract-info">
                                    <h2>{contractInfo.name} ({contractInfo.symbol})</h2>
                                    <p>總供應量: {contractInfo.totalSupply} / {contractInfo.maxSupply}</p>
                                </div>
                            )}

                            {claimInfo && (
                                <div className="claim-info">
                                    <h3>Mint 信息</h3>
                                    <p>已鑄造數量: {claimInfo.claimed} / {claimInfo.maxClaimable}</p>
                                    <p>單個錢包上限: {claimInfo.maxPerWallet}</p>
                                    <p>價格: {claimInfo.price} {
                                        networkInfo.chainId === '0x1388' ? 'MNT' : 
                                        networkInfo.chainId === '0x2105' ? 'ETH' : 
                                        'ETH'
                                    }</p>
                                    
                                    <div style={{ marginTop: '15px' }}>
                                        <input 
                                            type="number" 
                                            className="input-field"
                                            value={claimAmount}
                                            onChange={(e) => setClaimAmount(e.target.value)}
                                            min="1"
                                            max={claimInfo.maxPerWallet}
                                            disabled={isLoading}
                                        />
                                        <button 
                                            className="button"
                                            onClick={claim}
                                            disabled={isLoading || !claimAmount || claimAmount <= 0}
                                        >
                                            {isLoading ? 'Minting...' : 'Mint'}
                                        </button>
                                    </div>
                                </div>
                            )}

                            {error && (
                                <div className="error">
                                    {error}
                                </div>
                            )}
                            
                            {success && (
                                <div className="success">
                                    {success}
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<NFTWalletDemo />);
    </script>
</body>
</html>